

# 亿级流量系统多级缓存架构8-服务降级

在高并发场景下，当系统中的一些功能组件出现异常，无法继续提供服务器的时候，为了保证整体系统可用性，可以牺牲一部分功能依旧提供**有损服务**，就像华为的那张飞机的图片  
只是建立在资源隔离的前提下的，也就是用Dubbo、SpringCloud把各个组件做成微服务，有一个抛异常了，前面的就能catch住。一个组件down了，整体还能凑活着用

## SLA

服务等级定义 SLA（Service Level Agreement）是判定压测是否异常的重要依据。压测过程中，通过监控核心服务状态的 SLA 指标数据，您可以更直观地了解压测业务的状态。

SLA则是服务商与您达成的正常运行时间保证。

详见

https://help.aliyun.com/document_detail/111729.html?spm=a2c4g.11186623.3.3.19693e74AnPY9O

SLA 分为网络服务/云服务提供商的在线保证率和项目自身故障率

## 6个9 

2个9 = （1-99%）X24 X 365 = 87.6 小时 = 3.65天

3个9 = （1-99.9%）X24 X 365 = 8.76 小时

4个9 = （1-99.99%）X24 X 365 = 0.876 小时 = 52.56分钟

5个9 = （1-99.999%）X24 X 365 = 0.0876 小时 = 5.256分钟

6个9 = （1-99.9999%）X24 X 365 = 0.00876 小时 = 0.5256分钟 = 31秒

每提升一个9，难度呈指数级的增长。项目在本地跑的时候跟上线之后是完全不一样的，上线之后才能感受到应用存在多少漏洞

**AP**

12306、银行 要求强一致性。强一致性在高并发下很难实现，因为高可用了

## 降级处理

降的是一致性牺牲一下

### 兜底数据
最后的底线，最坏的情况发生也好歹有个数据。在抛异常的情况下给用户一个相对友好一点的页面
比如App没有联网的时候展示出来的数据，提前预埋一些数据，三种形式：

默认值: 设置安全的默认值，不会引起数据问题，比如库存为0，返回0，没法买了，但是整套业务没有终止，没抛异常

静态值:请求的页面或api无法返回数据，提供一套静态数据展示，比如加载失败提示重试，或默认菜单

缓存: 缓存无法更新便使用旧的缓存。缓存是多级的：nginx -> Redis -> java EHcache -> DB 每一次向后面去取数据的过程叫做"回源"。只读还好说，
比如一旦EHCache没有数据，他就去DB中拿，但是他如果本身就不可用了，这样就要返回没有数据的状态的信息给用户了，这个数据是默认值或者静态值。
一旦数据发生变更了，就一层层地往后面找，比如Redis里面没有，就层层往后面找，最坏的情况是写到DB返回，然后再把数据一层层同步回来，但如果Redis
这里同步失败了，就把原来老的值返回，凑活着看。这种场景适合于一致性要求不是很高的数据，比如评论、推荐系统推送

## 限流降级

当流量洪峰到达的时候，有处理的和抛弃的请求（503），对于丢弃的用户可以提供友好的提示

比如提示用户当前繁忙稍后重试等。nginx里面有50x的错误提示页面，不是重定向到某个错误页面。可以传递不同的参数，根据不同的情况返回不同的错误页面。
重写503页面，还可以在页面上加一个刷新按钮。限流也是万不得已，但是不这么做损失的用户可能更多

### 超时降级

对调用的数据设置超时时间，当调用失败，对服务降级。而不是阻塞在那里。这里也可以在一段时间之内重试，设置重试时间（@Retryable）重试是去不同的节点请求
开放的API很多情况下就是间歇性报错

### 重试/自动处理

客户端高可用：提供多个可调用的服务地址

微服务重试：dubbo重试机制

API调用重试：当达到重试次数后，增加访问标记flag，服务降级，异步探测对方服务是否恢复。当API不可用的情况下反复去探测。如果标识成不可用，就直接告诉
用户服务降级了。订酒店、订机票经常出现这种事。一旦探测到恢复了，就去更新一下flag，这个flag放在哪儿？zk、Redis（高并发系统下，DB一般人是碰不着的）
选择Redis稍好，因为不太需要强一致性。Redis和zk互相抄，但是还是分别保证AP（Redis）和CP（zk），所有的降级都是为了提高可用性，牺牲一致性。淘宝经常
搜索完了没展示出东西来，但是下一次又有了，这是AP。服务降级之后可以弹出个对话框，包含一个重试按钮，比较友好

WEB端：在服务不可用时，web端增加重试按钮或自动重试可以提供更友好的体验。

自动重试需设置重试次数和数据幂等处理，多次重试的超时之后的返回结果只处理一个。返回消息的时候有个唯一的标记，在被返回端处理，做一个迷瞪，相同的消息
只处理一次。整一个Map（Set），key是请求头，value是处理过还是没处理过

**理解了CAP原理，就理解了分布式架构的基础**

### 降级开关
如上所说，可以用Redis，也可以用zk，根据实际需要去选择

在服务调用方设置一个flag，标记服务是否可用

存储在第三方，配置文件、数据库、redis、zookeeper中。

### 数据组装降级
比如访问淘宝的时候，它的首页组合了N多模块，比如评论、商品等等，我们会请求好多的接口，这种请求怎么做？
多库/多维度组装JSON/XML时，如果有一些不重要的数据无法获取或数据出错，可以忽略继续。

### 爬虫和机器人

分析机器人行为：短时间连续操作，agent，行为轨迹、拖拽（模拟登陆/秒杀/灌水）

爬虫：引到到静态页或缓存页

### 读降级

在一个请求内，多级缓存架构下，后端缓存或db不可用，可以使用前端缓存或兜底数据

### 写降级

在cap原理和BASE理论中写操作存在于**数据一致性**这个环节，

降级的目的是为了提供高可用性，在多数的互联网架构中，可用性是大于数据一致性的。

所以丧失写入数据同步，通过上面的理论，我们也能勉强接受数据最终一致性。

高并发场景下，写入操作无法及时到达或抗压，可以异步消费数据/cache更新/log等方式

### 前端降级

当系统出现问题的时候，尽量让请求隔离在离用户最近的位置，避免无效链路访问

在后端服务部分或完全不可用的时候，可以使用本地缓存或兜底数据

在一些特殊场景下，对数据一致性要求不高的时候，比如秒杀、抽奖等可以做假数据

#### js降级

在js中埋降级开关，在访问不到达，系统阈值的时候可以避免发送请求

#### 接入层

可以在接入层，在用户请求还没到达服务的时候，通过、Nginx + Lua、Haproxy + lua

过滤无效请求和服务降级

#### 应用层降级

参考常老师项目中的springcloud

### 片段降级

页面中异步加载的数据，有一部分无法得到

js、css无法加载 -> 兜底 css

### 静态化处理

在活动前可以通过静态化技术，把原来需要调用多个动态接口的页面整体缓存下来保存成一个静态文件

当动态服务无法支撑的时候，降级为静态化服务

静态文件内尽量不去异步加载数据

静态文件包含可变内容，可以使用模板技术定时生成更新

### 提前预埋

APP 浏览器 js/css缓存大促前