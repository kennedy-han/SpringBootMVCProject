# Redis 产生背景

#### 1.1.数据存储的发展史

##### 1.1.1.磁盘时代

  很久之前，我们的数据存储方式是磁盘存储，每个磁盘都有一个磁道。每个磁道有很多扇区，一个扇区接近512Byte。

  **磁盘**的寻址速度是毫秒级的，带宽是GB/M的。**内存**是ns级的，带宽也比磁盘大上好几个数量级。总体来说，磁盘比内存在寻址上慢了接近10-100W倍。就带宽来讲，内存也比磁盘快很多，内存直接跟CPU的前端（数据）总线相连。

  在这段历史中，我们的面临的问题是，I/O问题。在读写文件时，我们常常面临很大的I/O成本问题。但是最初有个最初的解决方案是加一个buffer。

```
科普：什么是buffer？
  buffer是指一个缓冲区，我们在缓冲区来进行一个暂时的存放，之后统一运输给内存，这样会使得I/O的性能有略微提升。
```

##### 1.1.2.数据库的产生

  任何技术都不会平白无故产生。

  我们数据库技术就是由于磁盘的I/O瓶颈。为了解决这个问题，我们将磁盘扇区分为4K的一个个小的分区，构成索引。有了这些索引值，我们能通过索引，进行更加便捷的查找。索引也是使用的4k的存储模型，所不同的是它存储的是真是数据的位置，在哪个4k里存了
真是的数据。比如身份证表，每个身份证号指向了真是数据的data page。数据变多的时候，索引也会很多。为了我们能够更快的查找，对于关系型数据库表，必须给出schema就是每一列的类型、数据宽度，给出数据类型之后，每行数据的宽度就定死了，未来向表中
插入一行，假设一行有10个字段，我们只给出了第一个和第七个，往data page里面放的时候没有值的字段会用0填充，好处是：存的时候更倾向于行级存储，未来再设置为设置的字段的时候直接在0上面写就行了，不用移动数据。我们将索引在内存里使用B+树进行存储。
B+属所有的叶子就是这些索引“4k”小格子，B+树的树干是在内存里的，只要是select语句中的where条件命中索引了，B+树会走树干，最后找到某个叶子，把叶子从磁盘读到内存，再把对应的data page读进来就可以找到记录了。这样B+树和磁盘的安排可以发挥各自
的优势，获取数据时的IO减小。面试题：数据库表变得很大的时候，效率变低的原因是什么？如果表有索引，增删改会变慢，因为操作真实数据的时候也要修改其索引调整位置、维护索引；但是查询速度：1.假设内存和硬盘都存得下，来了一个或少量查询，则依然很快
2. 并发或者复杂的SQL过来了的时候会受到硬盘带宽的限制：10000个查询散布在很多不同的4k上，这样会造成拥塞。寻址和带宽都会限制查询速度。 总之，数据库变大的时候，增删改查都会变慢

```
科普：B+树是什么？
  我们普通的1-0树，又称二叉查找树（二叉排序树），二叉查找树和排序树是同一种树，就是单纯的1-0树，按照中序遍历的存储方式进行从小到大（从大到小）进行存储。（初学者可能误以为两种树，包括我刚开始学习数据结构的时候）。
  二叉查找树（二叉排序树）由于在插入和删除的时候，容易出现不太ok的情况，例如，可能在删除过程中删除为一个链表，这样查找效率依旧会变得很低。所以，我们使用旋转，通过左右旋转，将这种“链表”式（极端情况下）的树转化为左右平衡的树，这就是所谓的B-树。（注意误区，B树和B-树是一个树么？初学者认为后面一种是B减树，实际不是，是翻译过来的时候加的分隔符。B为Balance平衡的意思）
  当然，我们的数据库文件不是二叉的，文件系统也不是，所以，我们多叉的查找树，就是所谓的B+树。+号代表每个节点不止二叉的意思。
  
  （用自己的话粗略总结，详细还是看B-tree，B+tree的定义）
```

  在我们数据库的查找中，我们遇到一个问题？那就是字节宽度问题。我们建库的时候必须给出schema，我们行级存储，即使是该列为空，依旧要占位，那么，数据量庞大的时候，将会浪费很大的存储空间。但是这样的好处是，我们可以在update的时候不需要移动数据的位置。

##### 1.1.3.key-value数据库的产生



  任何技术都不会平白无故产生。

   我们将数据库发展到极致，产生出类似SAP公司的HANA数据库，是个内存级别的关系型数据库。这种数据库，硬件需求大，内存约2T，硬件+ERP软件+服务总和约2亿一个套餐。有一个问题是数据在磁盘和内存中的体积不一样，因为索引也是要占用磁盘空间的
磁盘里没有“指针”这个概念，磁盘里的数据会“胀出”，而且可以启动一些压缩和优化的策略。这是个数据库的极端，而一般的公司用不起，所以有了硬盘存数据+内存缓存的策略，把一些数据放到缓存，其中的技术有memcached、Redis.架构师必须要有技术选型
的能力：https://db-engines.com/en 架构师可以把一家公司带到上市或者破产。Redis是KV内存存储的 No1: https://db-engines.com/en/ranking/key-value+store 年薪20-30w必须懂Redis，简历上要有。技术选型或者跟项目组同事讨论的
时候，拿着https://db-engines.com/en/system/Redis和https://db-engines.com/en/system/MySQL之类的输出就可以了。Redis每秒1.5M此操作，latency小于1ms。关系型数据库也就是每秒几千   

```
Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets 
with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of 
on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.
```
其中strings, hashes, lists, sets等五大类型指的都是value的类型

   随着互联网的发展，我们面临了一个新的问题。如何才能抵挡高并发，以及大数据导致的查找变慢呢？（注意，数据量变大，仅仅影响多数据查找，单数据查找并不会影响性能。我们的业务逻辑，通常是多条数据查找，所以才会有瓶颈）

   于是我们的k-v数据库产生了，这依赖于两个基础设施。冯诺依曼体系的硬件，以太网，和tcp/ip网络（不稳定，数据一致、双写等问题）。**参考附件：冯诺依曼体系图**

```
科普：什么是冯诺依曼体系？
  我们的操作系统老师是个年纪很大的教授，这边引用他的上课原话。
  冯诺依曼体系，至今没有一个明确的定义。有的书说有5个，有的书说有7个，但是，我依照某年考研题，来规范一下冯诺依曼体系。
  冯诺依曼体系由五部分组成，控制器，运算器，内存，总线，硬盘和I/O接口6部分组成。
  
  （如何记忆冯诺依曼体系构成：CPU分为控制器运算器，其他都为CPU服务，运算需要内存，连接需要总线，我们要读写必须要I/O接口。一切以CPU考虑，就能记全6个）
  
  参考附件：冯诺依曼体系图
  
```

