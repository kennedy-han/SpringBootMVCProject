# 面试题

设计一个歌曲排行榜（并不是整个歌曲网站，而只是排行榜这个模块），由于用户网页上访问，所以要尽量快速响应。

1. 设计系统，给定广大听众点击歌曲的统计数据，如：歌曲1->100次；歌曲2->150次..... 用户点击“歌曲排行榜”时，系统给出在Top 10的歌曲名称，顺序从高到低的排序。假设数据是静态、不变的。（初级）
2. 如果不只要1-10名，而是可以根据用户要求，显示任意窗口（比如点击量在23 - 58名，100 - 200名）的歌曲，且排名要根据万级用户对歌曲的点击而实时变化 （中级以上）
3. 能说解释一下为什么你设计的系统能扛得住万级以上的并发量吗？原理是什么？如何在如此高的并发之下仍然能保证统计数据的准确性？ （高级）
4. 系统底层用了什么数据结构？实现了快速响应（高级，答出来可以考虑聊薪水了）

# 参考答案

1. 解法1: 静态数据量不大的话可以直接在内存计算：类似于Leetcode 347，具体解法不多说。这里假设了歌曲数量总不会太多，假设1万首，歌曲名字平均50个字节，所以内存中不会占用很多空间。  
   解法2: 把数据存到Redis里面，存成sorted_set，每个元素的分值（score）就是点击量，然后倒序排列，并取出1-10名
2. 同以上解法2，只不过范围参数要根据用户的输入灵活设置
3. Redis使用了epoll，用户请求过来的时候，先到达网卡，然后是操作系统内核，而epoll让用户态和系统内核态可以共享内存，请求过来的时候可以不用从用户态转换为内核态就可以知道那些连接的文件描述符有数据过来了，并把它们放到一个链表中
   给用户态读取数据，从而避免了无论是在用户态的NIO轮询还是在内核态多路复用的轮询（后者会传递所有的连接的文件描述符到内核态，然后轮询，比epoll慢）。  
   
   由于Redis是单进程单线程的，所以各个请求被并行处理，这就保证了不会有同一数据同时被两个线程修改而状态不一致的问题，从而使统计数据准确无误。
   
   **理论上可行但实际上糟糕的做法**：数据存在数据库每次都查询数据库，然后sortedBy 点击量，再分页取出前十名...这样直接访问数据库，而数据库的大延迟扛不住这么高的并发，数据库是硬盘访问，响应时间在ms级别，而Redis在内存，响应时间在
   ns级别，相差10万倍。
4. 其实是sorted_set的底层实现：skipList，跳表。答出来就行了，最多画图描述一下结构