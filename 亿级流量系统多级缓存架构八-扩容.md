# 扩容

扩容的原因

单体应用 -> 平均

## 硬件与云服务扩容

### 整机硬件

整机：IBM、浪潮、DELL、HP等
换来的是多线程的性能和可扩展的特性，以及对于服务器内存的数据的校验，最终的就是稳定性。开机一年不关机。磁盘转速高、此片少会比较好

### cpu

Intel、Amd 单路，双路，四路
CPU变多了，跑多线程更有效率。进程绑定到物理CPU的内核，做到这样是最能发挥服务器性能的
### 网卡

千兆 -> 万兆  
万兆网卡要配合万兆交换机、网线，千兆和万兆的差距是巨大的，万兆主要用在大数据日志同步、主从复制等场景

### 内存

ECC校验，避免内存存储数据出错的，性能上会有一定的损耗

### 磁盘

SCSI HDD（机械）、HHD（混合，磁盘自带一块内存，云盘用机械的）、SATA SSD、PCI-e SSD、 MVMe SSD（速度最快，坏的也最快，注意备份）

<img src="../../../Downloads/InternetArchitect-master/12%20亿级流量多级缓存高并发系统架构实战/images/d1160924ab18972bf2919884ebcd7b899f510ad0.jpg" alt="img" style="zoom:50%;" />



## 水平扩容（集群）

复制

统一入口 负载均衡

## 系统拆分 （分布式）

随着业务的增长，系统变得越来越庞大

根据系统功能拆分成独立而又互通的项目

比如交易系统、财务系统、生产流程系统、物流系统、网站系统等等

拆分完成会发生以下问题

- 系统间共享数据

  - 中央数据中心，数据库集群
  - 独立资源，消息中间件异步消费数据

- 接口调用

  - rpc rmi dubbo
  - http restful

- 持久化数据雪崩

  - 数据库分库分表
  - 资源隔离
  - 对访问量大的

- 静态资源分布在各个系统中

  - 防刷
  - cdn技术统一分发管理

- 高并发问题

  - 缓存
  - 数据闭环

- 数据一致性问题

  - 分布式锁

  

### 多库join

#### 增加冗余字段设计

#### 向多库发n次查询（最low的，这事其实没问题，只是其他业务不方便，还要建立多个数据库的连接，连接池的治理、网络开销是个问题）

#### 复制表到本地数据库（表级别的冗余），中间靠job定期同步全量数据，MQ、binlog同步增量数据

#### 使用搜素引擎（ES，相当于MySQL前面做了一层检索上的缓存） 
有可能产生join的字段组织成一个字典文件，放到ES里面有几个数据库就往ES里扔多少，ES不太害怕数据库变大

#### 连接表

以MySQL为例，链接表与常见的 MyISAM, InnoDB 等等，都是一种表的结构类型（称之为 存储引擎）。使用 show engines; 命令即可看到数据库所支持的存储引擎，默认 FEDERATED 引擎 是关闭的，我们需要去mysql配置文件开启它。

![mysql](../../../Downloads/InternetArchitect-master/12%20亿级流量多级缓存高并发系统架构实战/images/13c7000a9428f45fba71.jfif)

开启的方法很简单，在windows下只需要在mysql的配置文件 my.ini 最末尾加上一句 federated ，然后重启mysql即可。重启后输入 show engines;命令即可看到 FEDERATED 的 Support 变为 YES，表示federated引擎已经开启。

**链接的表，那么会有以下几个限制：**

- 本地的表结构必须与远程的完全一样
- 远程数据库目前仅限MySQL
- 不支持事务
- 不支持表结构修改

**一个例子**

```sql
        CREATE TABLE TABLE2 (
        id     INT(20) NOT NULL AUTO_INCREMENT,
        name   VARCHAR(32) NOT NULL DEFAULT '',
        other  INT(20) NOT NULL DEFAULT '0',
        PRIMARY KEY  (id),
        INDEX name (name),
        INDEX other_key (other)
        )
        ENGINE=FEDERATED
        DEFAULT CHARSET=latin1
        CONNECTION='mysql://192.168.1.2:3307/DB2/TABLE2';
```
CONNECTION把MySQL的URI给加上了（用得不多，张一鸣也没用过，也没法跨平台）  
用得最多的还是ES。对数据一致性要求比较高的话，就要不断的去重建数据索引，检索的数据需要一段时间才能把索引给重建出来
## 分布式ID

并发场景下的id生成策略

### 分布式ID需求

一个数据库里面有好几台机器，分库分表之后，第一台机器产生了个4号ID，还没同步到第二台，这时候在第二台上又创建了一条4号ID的记录

- 全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。

- 递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。这个ID可以代表createDate，有时序性

- 信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。  
          可以用图片防止被扒，把字写到图片里面。JD的详情页的商品介绍全是图，还加了水印。被偷走了之后正好帮他打广告。但是自己查产品信息的时候是不好查的，额外再加一个标签，或者描述要放到另外一个
          地方。做电商的话，产品详情页，如果是2b或2c，对方卖的东西如果是违禁品，怎么查？这就要用图像识别技术，把里面的文字和图像给筛选出来。还有一个办法是加小尾巴，明明是复制粘贴，怎么粘出来
          还有很多作者信息？在传过来数据的后面多了一堆广告。。。js可以把样式处理一下，隐藏尾巴的div，然后扒走了之后对方看起来全是小尾巴和广告。原来low的时候正文最后有好多小点儿，其实是字体缩得
          都不能再小了。接口也可以这么做
- 极高的可用性
- 高并发



单机id 自增和随机哪个效率高？

### 分布式ID方案

#### 全局唯一数据库

集群中唯一的一台数据库服务器

**特点**

- 实现简单
- 性能一般，难扩展
- 维护
- 整形id自增，分页，排序等需求很方便。专门拎出来一台机器出来，跑MySQL，做成一个ID生成器，几台存储服务器从ID生成器中取出ID。操作的时候往ID生成器插入一条记录，返回他的ID写回各个存储服务器。能用
  第三方的服务就不要自己去开发，太麻烦，有很多想不到的问题
- 由于每个数据库产品对id生成策略实现不同，数据库中的数据迁移跨数据库平台需要处理
- 单点故障问题



#### 数据库集群生成方案

避免重复，设置成`起始数字不一样，步长一样`两台存储服务器就设成奇偶数



#### UUID

可以用数据库生成，也可以用代码生成

- 简单
- 不可读、不好排序
  - 变种，替换或增加字段用来存储生成时间，方便排序。但一定不允许改时间
- 生成性能好，没有网络开销
- 全球唯一，数据合并一般不会出问题
  - mac地址，原子钟（在原子钟看来不存在两个人同时做一件事的情况，小数点后面你就数吧）
  - 保证服务器时间不回退
- 无法排序，没有递增关系
- 字符串存储空间大，查询效率较低
- 数据传输量大

#### zookeeper

自身高可用，原子性、数据可以做强一致

- 有序，使用**临时序号节点** zk下线再上线会从上次的ID号继续递增编号
- 使用节点的数据版本号 update时候version number zxid不一样
- 高并发下性能不好。主从复制，一个leader写，其他的在一边看着，写完了再同步

#### MongoDB

使用ObjectId，原生分布式数据库

#### Redis

单线程的redis可以提供原子特性及高性能。自增实现

实现分布式id可以用Redis的原子操作 INCR和INCRBY来实现，做Redis集群的时候可以`起始数字不一样，步长一样`

- 高性能。效率远远高于zk，纯玩儿内存的
- 数字id，排序，分页方便
- 局部有序，全局无法保证有序

#### snowflake

snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID

这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等，比如在snowflake中的64-bit分别表示如下图

![image](../../../Downloads/InternetArchitect-master/12%20亿级流量多级缓存高并发系统架构实战/images/eee18df9.png)

其中有41位的时间戳、10bit的workerID和10位的序列号（序列号是单线程内的。这个策略就跟身份证号的产生算法一样）

- 性能好
- 单机上是递增的，强依赖机器时钟，分布式系统中无法保证每台机器时钟都一样，所以不是全局递增
- 严重依赖时钟，禁止机器上时钟回拨
（后面会详细讲）


## 分布式事务
两三阶段提交，后面讲，麻烦

## 弹性扩容
用多少来多少机器（虚拟机，跟容器docker啥的还不一样）单机版的MySQL还是很强的，比Oracle、DB2这种商用的稍弱一点  
往MySQL里面写日志，达到了2亿条记录的时候就不往这里面写了，而是调起脚本或者唤醒程序员，把另一台机器给我开开，然后自动的把写入请求切换到第二台机器上，第二台又满了，再启动第三台...在写的时候做弹性
扩容。机器的IP什么的都是动态的去取的，但是我们不知道有多少台机器、他们的IP都是什么，所以这些机器在启动的时候就要向注册中心注册，然后别人就取得到了。  
当访问量达到阈值的时候LB可以感知得到，这时候通过动态添加容器也能做到扩容，基于shell脚本，启动新容器，并将其加到nginx里，然后reload nginx。所以**容器是弹性扩容的核心技**。不详细探究了，这部分是运维关注的

### 虚拟机

第一，虚拟机弹性能力较弱。使用虚拟机部署业务，在弹性扩容时，需要经过申请虚拟机、创建和部署虚拟机、配置业务环境、启动业务实例这几个步骤。前面的几个步骤属于私有云平台，后面的步骤属于业务工程师。一次扩容需要多部门配合完成，扩容时间以小时计，过程难以实现自动化。如果可以实现自动化“一键快速扩容”，将极大地提高业务弹性效率，释放更多的人力，同时也消除了人工操作导致事故的隐患。

第二，IT成本高。由于虚拟机弹性能力较弱，业务部门为了应对流量高峰和突发流量，普遍采用预留大量机器和服务实例的做法。即先部署好大量的虚拟机或物理机，按照业务高峰时所需资源做预留，一般是非高峰时段资源需求的两倍。资源预留的办法带来非常高的IT成本，在非高峰时段，这些机器资源处于空闲状态，也是巨大的浪费。