# 亿级流量系统多级缓存架构9-分布式事务

亿级流量系统多级缓存架构9-分布式事务.md跟区块链联系比较紧密。微服务里面每一个服务里面都有数据，但是他是基于微服务的，
区块链是基于客户端的，挖矿程序或者钱包是每一个节点，他们里面都有数据，这些数据是共享的，改他的时候，需要一个主节点，
改完之后再广播到所有的子节点上，广播比较慢（12306需要强一致性，造成的可用性降低，所以就容易崩）

## 为什么分布式事务？

### 传统事务的基本特性（ACID）

**mysql**中，我们可以使用begin开始事务，rollback回滚事务，commit提交事务

redolog 记录变更、undolog回滚（写日志、回滚日志）。数据库不支持事务的情况下，三条语句如果最后一条失败了，就很难回滚前面两条。如果有
Delete操作要回滚，就要insert，如果id是自增字段，那ID就变了，前后数据就不一致了。多节点时，数据一致性是个大问题

Spring中，使用@Transaction标记事务

一个DB如果保证了以下4点，就可以说他支持事务

#### 原子性（Atomic）

要么全部成功，要么全部失败，没有中间状态

#### 一致性（Consistency）

指的是在执行事务前后，事务外访问数据的时候，数据是一致的，要么看到的是成功的，要么看到的是失败的结果，不会多任务查询到的数据不一样。

#### 隔离性（Isolation）

一个事务在未完成时，另一个事务不会影响到他。四个特性中最基础、最根本的一个特性。如果正在更新某几张表，其他的事务是不许进来打断的

#### 持久性（Durability）

会有持久化效果，改变是永久的

随着系统越来越庞大，我们为了提高可用性、维护性、吞吐量等等技术指标，可以采用SOA来改善原有架构，业务计算的问题解决后，数据库便成了整个系统中的瓶颈

### 分库分表
字段一多了，表的整体容量变大，查询的时候有些字段可能没有值，或者不想选出来，则产出数据量变大，网络IO变多，查询效率也会变低。索引不是瞎用的。
大表分成两个小表，放到两个库里，用join查询，不同的业务线稍微隔离一下，放到两台机器上去做负载，吞吐量也上升了
数据库集群/分布式存储方案在当前最主流的便是采用分库分表方案做多机存储和负载

分库分表能减少单表

在多机存储的环境下，传统的事务机制便无法正常运行了。

#### 表垂直拆分
行数越多，查询效率越低，这是有数据库查询机制引起的。做了索引还好能够直接定位过去，读这一行数据；否则要一个个拿出来和条件匹配
把表中的列拆分成多个部分，就是把一张很多字段的表，拆分成多个表。
    1. 一张表里就只有100条数据
    2. 哈希算法，提供简单的索引
工具：mycat（实现一定的数据一致性和一致性哈希）
- 减少查询时候的网络i/o
- 提高查询效率

#### 表水平拆分

按行拆分，一张表里的行数越多，查询效率越低

水平拆分指定就是把原来的一张表中存放的数据按照固定行数拆分成多个表来存储

- 有效的提高查询效率

分表后依然可以使用本地事务，但是单机负载依然是瓶颈。

#### 分库
使用场景：一个库有点顶不住当前的流量了（复杂查询），需要增加吞吐量
分库指的是变成了多节点

- 同样的表结构（数据可以不一样）
- 不同的数据库中
- 每个节点中保存副本数据或分布式存储
- 可以把事务路由到同一库中（很难做到，看分库分表的时候是怎么拆的，如果是竖着拆的，把字段给拆开了，就难办了，有可能跨库查询），
  则可以保证事务特性，尤其是强一致性。ACID中CI是最重要的。一致性分为强一致性（数据库的事务），弱一致性（能提供高可用性）
  火车票的超卖和少卖就是在分布式系统下没办法保证数据的强一致性
- 当数据分散到数据集群中做跨库查询的时候，无法保证强一致性

#### 微服务下的多库存储

#### 回想CAP定理和BASE理论

base通过允许损失部分可用性来提高数据最终一致性

## 海量数据/高并发系统分布式事务解决方案

### 强一致性

强一致性会带来系统大量的损耗，存在单点故障问题，在提交事务阶段会产生阻塞，直到结束才会释放资源。高并发场景下表现并不好。

#### 二阶段提交协议

![img](../../../Downloads/InternetArchitect-master/12%20亿级流量多级缓存高并发系统架构实战/images/8af234a0-6ed1-11e9-9f49-6f4505f5df5e)

举这么一个案例：一个点上的系统中，要生成订单就必须 1. 查、改库存 2. 联系物流 3. 生成订单。 有一个环节出问题则整个事务就失败

二阶段提交协议可以保证数据强一致性

二阶段

- 准备，预提交，先检查一下，在数据库层面和应用层，会包含业务逻辑，执行一次检查，检查整套事务走一遍能不能够成功，不能的话就不用真的提交了
- 提交，很多商用数据库是支持的，但是MySQL不支持。弄一个第三方的业务组件或者技术框架，去检查能不能提交事务成功，能成功的话，反馈回去，
  或者从他这里就直接提交了。提供强一致性，如果有一个失败了，全部都回滚。中间节点负责一致性的协调
  这有几个问题：1. 中间的这个服务或者组件挂了（做高可用的话技术架构会更复杂, 事务的信息要传播到备用节点）。2. 中间节点做回滚的时候失败。
              3. 检测的时候有人改了数据。 4. 并发会产生同步等待，检查一张表的修改可不可行的时候，这张表一旦返回得慢了，就要阻塞等待。
              等待时间这么长，就不太可能保证这个数据不被别人动。5. 被检查端单节点故障
  这些问题都可能造成数据不一致：前面两个表改了，后面没改。解决这种问题最简单的方式是记日志。只能让提交方记日志，因为数据库那边可能网络就
  不通。中间有个预提交就避免了一次提交不成功还得分别回滚
  
##### 两阶段提交的意义
没有中间这个框架或者服务的话，想完成这个事务就必须区分比访问三个数据库或者三个服务。事务是多件事组成的，三个查询是串行执行，一个人在改
一个数据库中的数据的时候，别人不能改，得让别人知道有人在改，有个中间的服务或者框架统计。独立出的这个服务，标记出三张表中的三条要求改的记录，
别人这会儿谁也不能改了（事务的隔离特性）。需要一个"第三方"去记录什么东西将要被修改，他就相当于一个分布式锁。  

记录好了之后也不是直接去commit创建订单等请求，得先看一下各个步骤能不能成功，这需要做预创建，数据库原声可以做这个（redolog/undolog），
也可以写代码的方式预创建，被create的记录里多加一个status，初始标识为"creating"，同样道理另外两个数据库也是同样方式创建，如果全都成功，
"第三方"收到反馈，说没问题，预创建记录创建成功（但此时不生效），接下来就真的commit，把creating改成done。如果失败，则把这个status记作：
"avoid"，然后定期把这些记录转移到日志表里面，或者直接记到日志文件之后再把它从这个表里删除（业务系统里很少直接删记录，自增ID非常不重要）

二阶段提交是一套不完善的解决方案，但是他能够给我们提供一套强一致性的解决方案。分布式事务里的回滚不一定是删记录，不要把这里的事物跟数据库的
事务强一致性的ACID混为一谈，效果能达到就行，真正数据库一样的ACID的强一致性分布式系统是做不到的，只有单节点才能做得到

角色: 

- 协调者
  - 负责收集准备信息（预提交）
  - 准备完成，发起正式提交
- 参与者
  - 数据库

二阶段提交把事务分为两个阶段，即准备阶段和提交阶段，准备阶段负责收集每个参与者提交数据的预提交信息，其实是收集每个数据节点是否能够成功执行命令，

如果其中某些节点无法执行，那么会反馈给协调者失败信息，然后协调者会发送回滚信息到每个数据节点以保证一致性

如果全部返回准备好的消息，那么协调者会正式向数据节点提交数据变更。

##### 问题

**同步执行**

每一次收集准备信息都需要等所有数据节点返回信息，造成同步等待。

**单点故障**

需要考虑数据节点和协调者的单点故障问题

**执行提交**

数据节点提交变更，无法保证是否真正提交了

二阶段提交存在很多潜在和小概率问题，那么在数据一致性要求高的场景下会造成数据不一致的现象发生，一旦发生数据不一致的情况后，后续人工干预的操作
会浪费大量的时间，对银行、余额这类业务，还有可能造成资产流失。

#### 三阶段提交协议

三阶段提交是对二阶段提交的改良版本，增加了预备阶段，在二阶段提交的准备阶段之前增加了网络连接的校验，不同的实现方案对于这个预备的定义不太
一样，可以去检查一下节点是否存活、网络链接通不通、CPU内存占用率是否过高等。在这一阶段是不会写入数据的。解决了同步阻塞问题。数据库是不支持
三阶段提交的。

仍然有问题，只是多了一次检查而已。光靠数据库和我们自己的代码是比较麻烦的



#### TCC模式

![img](../../../Downloads/InternetArchitect-master/12%20亿级流量多级缓存高并发系统架构实战/images/0e53e470-6ed1-11e9-8477-e9d92585d062)

**TCC**

TCC解决的不只是数据库，还有在微服务架构下，有很多服务节点，我们想要去跨服务查询别人的数据库，别人可能不同意，那只能去访问对方的API，API
只给出访问结果。这种形式不走数据库的话TCC也能支持，TCC就是我们手动实现出来的两阶段提交的具体方案。有很多的技术框架也实现了TCC

Try

- 尝试（能不能写入数据库表）
    - 检查网络
    - 完成所有业务检查
    - 隔离预留资源

需要一个小弟来记录谁正在操作那些东西，别人再来的时候要等前面这个人完事儿了才行

Confirm

- 真正的执行业务
- 使用try阶段预留的资源
- 幂等。比如第一次创建订单没创建成功，有个补偿机制，就是Retry，这要限定次数和时间。幂等是接收到相同的请求，效果跟只执行一次是一样的。
  如何分辨哪个操作需要做幂等，所以TCC需要一个上下文，贯穿整个try、confirm、cancel阶段。try和confirm就不是一个人发起的。TCC模式下，
  分布式事务是由主线业务发起的（主线业务的service可能要调用其他的服务），他来开启事务，这时候会给想要执行的事务加一个事务ID，这一系列的
  连锁操作全部标记在一个事务ID里，这是主线业务向TCC框架或者自己的手动实现（大厂自己写）提交这些信息。在做回滚/提交和幂等的时候都可以根据
  这个事务ID来分辨事务之间的隔离了，比如删除和创建订单有冲突，开启事务的时候还会在TCC框架的"小黑板"上写上（相当于分布式锁，有一个表）有
  那些资源是隔离的。相同的ID不再处理第二次，这就幂等了。后面的Confirm 和Cancel也是通过这个事务ID和主线业务绑定。TCC提供的功能叫"事务
  管理器"，主要就是生成事务ID、执行TCC相关的操作。Try操作是主线业务做的，比如主线业务调用了service A、B、C，则主线业务先去try，成功之后
  提交到事务管理框架里，后者记录这些信息，执行下面的操作：生成事务ID，开启分布式事务、上下文、执行Confirm操作。如果前面主业务的try都没有
  成功，则事务管理框架就不做了，不提交，直接就回滚了。这里的事务管理器跟前面的二阶段提交的区别就是这里多加了很多"补偿机制"：confirm的时候
  如果出错了，能够cancel掉。二阶段提交的时候如果try成功但是confirm失败的话也不好整，而且也没做到资源隔离。所有confirm都成功，则返回到主
  业务，则这次分布式事务执行成功；有一个confirm失败，有这么几种补偿机制：1. 重试 2. 消息队列。事务不一定是有多个操作组成的。一个节点往
  另一个节点（不是数据库）写东西，要求一定要到达：发请求，对方执行，返回结果。不管什么解决方案，网络是无法保证100%联通的，来回的消息都
  不一定能到达。这可以用消息中间件，往MQ里面去写，然后MQ返回一个ack。对方业务进程中消费MQ中的消息，消费成功之后再给请求发起方一个回馈。
  这里的问题是往MQ里面写可能没写进去，那就保证最终一致性，往MQ里面没写进去的话，可以在本地的数据库里写或者记录一个log。MQ往消费端投递消息
  的时候也不一定就成功，所以有个重试次数（MQ里有配置），这时候请求发起短短的DB或者log就起作用了，MQ如果没投递成功的话，通知请求的发起端，
  重新写一下。或者说这个MQ支持预投递，跑job检查消费端有没有拿到消息，请求的发起端本地DB里有没有这条消息，双缓存保证数据一致性。Job效率有
  点低，强一致性效率就高不了。定时任务可以用Quarz、xxl-job、Elastic-job，定时再次提交，或者下次访问的时候解决上次的问题（堆积的消息
  一次性又消费了） 3.定时核对校对（跑Job做审计），比如银行系统每个月都会有几天维护，包括10086，每个月的月初做清算，看数据能不能对上，
  跑日志校对，他不能实时校对，太影响性能，所以只能每周或者每个月一次，哪些数据错了，找出来，自动更正是很难的。跑Job分析日志的时候就需要
  大数据分析了。

Cancel

- 回滚

其实就是个两阶段提交，把准备阶段换了个名字而已，然后把两阶段提交的业务更加完善了一下。

主业务

- 发起事务

事务管理器

- 执行tcc操作
- 创建事务ID来记录整个事务链路
- 实现嵌套事务业务逻辑

执行流程

第一阶段

- 主业务调用所有子业务的try操作
- 事务管理器记录操作日志

第二阶段

- 所有try操作成功时，事务管理器执行confirm操作
- 有失败时，执行回滚cancel操作



t -> cc **关系绑定**

T是由主业务发起的，CC操作和T操作不在一台机器上

- 通过配置文件
- 通过Spring注解

try阶段进行了锁定资源操作，锁定不成功就认为是不可进行的，锁定成功就最终一定会成功。

##### 框架

**tcc-transaction**

https://github.com/changmingxie/tcc-transaction

**Hmily**

https://dromara.org/website/zh-cn/

**ByteTCC**

https://github.com/liuyangming/ByteTCC



![img](../../../Downloads/InternetArchitect-master/12%20亿级流量多级缓存高并发系统架构实战/images/hmily-framework-1572255210660.png)

**AOP**

TCC 通过AOP，面向切面编程来对confirm/cancel操作透明化

**幂等**

数据库中的唯一索引

分布式锁

状态机

#### 补偿模式

重试

固定次数，固定时间，消息队列，定时任务

下一次访问修复

定时校对/核对 quartz、xxl-job、elastic-job





事务 一定是由多个操作组成的吗？

